#ifndef yy_hlwHEADER_H
#define yy_hlwHEADER_H 1
#define yy_hlwIN_HEADER 1

#line 6 "jsgf_scanner.h"

#line 8 "jsgf_scanner.h"

#define  yy_hlw_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define yy_hlw_FLEX_MAJOR_VERSION 2
#define yy_hlw_FLEX_MINOR_VERSION 5
#define yy_hlw_FLEX_SUBMINOR_VERSION 35
#if yy_hlw_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

#ifdef __cplusplus

/* The "const" storage-class-modifier is valid. */
#define yy_hlw_USE_CONST

#else	/* ! __cplusplus */

/* C99 requires __STDC__ to be defined as 1. */
#if defined (__STDC__)

#define yy_hlw_USE_CONST

#endif	/* defined (__STDC__) */
#endif	/* ! __cplusplus */

#ifdef yy_hlw_USE_CONST
#define yy_hlwconst const
#else
#define yy_hlwconst
#endif

/* An opaque pointer. */
#ifndef yy_hlw_TYPEDEF_yy_hlw_SCANNER_T
#define yy_hlw_TYPEDEF_yy_hlw_SCANNER_T
typedef void* yy_hlwscan_t;
#endif

/* For convenience, these vars (plus the bison vars far below)
   are macros in the reentrant scanner. */
#define yy_hlwin yy_hlwg->yy_hlwin_r
#define yy_hlwout yy_hlwg->yy_hlwout_r
#define yy_hlwextra yy_hlwg->yy_hlwextra_r
#define yy_hlwleng yy_hlwg->yy_hlwleng_r
#define yy_hlwtext yy_hlwg->yy_hlwtext_r
#define yy_hlwlineno (yy_hlw_CURRENT_BUFFER_LVALUE->yy_hlw_bs_lineno)
#define yy_hlwcolumn (yy_hlw_CURRENT_BUFFER_LVALUE->yy_hlw_bs_column)
#define yy_hlw_flex_debug yy_hlwg->yy_hlw_flex_debug_r

/* Size of default input buffer. */
#ifndef yy_hlw_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, yy_hlw_BUF_SIZE is 2*yy_hlw_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define yy_hlw_BUF_SIZE 32768
#else
#define yy_hlw_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

#ifndef yy_hlw_TYPEDEF_yy_hlw_BUFFER_STATE
#define yy_hlw_TYPEDEF_yy_hlw_BUFFER_STATE
typedef struct yy_hlw_buffer_state *yy_hlw_BUFFER_STATE;
#endif

#ifndef yy_hlw_TYPEDEF_yy_hlw_SIZE_T
#define yy_hlw_TYPEDEF_yy_hlw_SIZE_T
typedef size_t yy_hlw_size_t;
#endif

#ifndef yy_hlw_STRUCT_yy_hlw_BUFFER_STATE
#define yy_hlw_STRUCT_yy_hlw_BUFFER_STATE
struct yy_hlw_buffer_state
	{
	FILE *yy_hlw_input_file;

	char *yy_hlw_ch_buf;		/* input buffer */
	char *yy_hlw_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_hlw_size_t yy_hlw_buf_size;

	/* Number of characters read into yy_hlw_ch_buf, not including EOB
	 * characters.
	 */
	int yy_hlw_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_hlw_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_hlw_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_hlw_at_bol;

    int yy_hlw_bs_lineno; /**< The line count. */
    int yy_hlw_bs_column; /**< The column count. */
    
	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_hlw_fill_buffer;

	int yy_hlw_buffer_status;

	};
#endif /* !yy_hlw_STRUCT_yy_hlw_BUFFER_STATE */

void yy_hlwrestart (FILE *input_file ,yy_hlwscan_t yy_hlwscanner );
void yy_hlw_switch_to_buffer (yy_hlw_BUFFER_STATE new_buffer ,yy_hlwscan_t yy_hlwscanner );
yy_hlw_BUFFER_STATE yy_hlw_create_buffer (FILE *file,int size ,yy_hlwscan_t yy_hlwscanner );
void yy_hlw_delete_buffer (yy_hlw_BUFFER_STATE b ,yy_hlwscan_t yy_hlwscanner );
void yy_hlw_flush_buffer (yy_hlw_BUFFER_STATE b ,yy_hlwscan_t yy_hlwscanner );
void yy_hlwpush_buffer_state (yy_hlw_BUFFER_STATE new_buffer ,yy_hlwscan_t yy_hlwscanner );
void yy_hlwpop_buffer_state (yy_hlwscan_t yy_hlwscanner );

yy_hlw_BUFFER_STATE yy_hlw_scan_buffer (char *base,yy_hlw_size_t size ,yy_hlwscan_t yy_hlwscanner );
yy_hlw_BUFFER_STATE yy_hlw_scan_string (yy_hlwconst char *yy_hlw_str ,yy_hlwscan_t yy_hlwscanner );
yy_hlw_BUFFER_STATE yy_hlw_scan_bytes (yy_hlwconst char *bytes,int len ,yy_hlwscan_t yy_hlwscanner );

void *yy_hlwalloc (yy_hlw_size_t ,yy_hlwscan_t yy_hlwscanner );
void *yy_hlwrealloc (void *,yy_hlw_size_t ,yy_hlwscan_t yy_hlwscanner );
void yy_hlwfree (void * ,yy_hlwscan_t yy_hlwscanner );

/* Begin user sect3 */

#define yy_hlwwrap(n) 1
#define yy_hlw_SKIP_yy_hlwWRAP

#define yy_hlwtext_ptr yy_hlwtext_r

#ifdef yy_hlw_HEADER_EXPORT_START_CONDITIONS
#define INITIAL 0
#define COMMENT 1

#endif

#ifndef yy_hlw_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef yy_hlw_EXTRA_TYPE
#define yy_hlw_EXTRA_TYPE void *
#endif

int yy_hlwlex_init (yy_hlwscan_t* scanner);

int yy_hlwlex_init_extra (yy_hlw_EXTRA_TYPE user_defined,yy_hlwscan_t* scanner);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yy_hlwlex_destroy (yy_hlwscan_t yy_hlwscanner );

int yy_hlwget_debug (yy_hlwscan_t yy_hlwscanner );

void yy_hlwset_debug (int debug_flag ,yy_hlwscan_t yy_hlwscanner );

yy_hlw_EXTRA_TYPE yy_hlwget_extra (yy_hlwscan_t yy_hlwscanner );

void yy_hlwset_extra (yy_hlw_EXTRA_TYPE user_defined ,yy_hlwscan_t yy_hlwscanner );

FILE *yy_hlwget_in (yy_hlwscan_t yy_hlwscanner );

void yy_hlwset_in  (FILE * in_str ,yy_hlwscan_t yy_hlwscanner );

FILE *yy_hlwget_out (yy_hlwscan_t yy_hlwscanner );

void yy_hlwset_out  (FILE * out_str ,yy_hlwscan_t yy_hlwscanner );

int yy_hlwget_leng (yy_hlwscan_t yy_hlwscanner );

char *yy_hlwget_text (yy_hlwscan_t yy_hlwscanner );

int yy_hlwget_lineno (yy_hlwscan_t yy_hlwscanner );

void yy_hlwset_lineno (int line_number ,yy_hlwscan_t yy_hlwscanner );

yy_hlwSTYPE * yy_hlwget_lval (yy_hlwscan_t yy_hlwscanner );

void yy_hlwset_lval (yy_hlwSTYPE * yy_hlwlval_param ,yy_hlwscan_t yy_hlwscanner );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef yy_hlw_SKIP_yy_hlwWRAP
#ifdef __cplusplus
extern "C" int yy_hlwwrap (yy_hlwscan_t yy_hlwscanner );
#else
extern int yy_hlwwrap (yy_hlwscan_t yy_hlwscanner );
#endif
#endif

#ifndef yy_hlwtext_ptr
static void yy_hlw_flex_strncpy (char *,yy_hlwconst char *,int ,yy_hlwscan_t yy_hlwscanner);
#endif

#ifdef yy_hlw_NEED_STRLEN
static int yy_hlw_flex_strlen (yy_hlwconst char * ,yy_hlwscan_t yy_hlwscanner);
#endif

#ifndef yy_hlw_NO_INPUT

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef yy_hlw_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define yy_hlw_READ_BUF_SIZE 16384
#else
#define yy_hlw_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef yy_hlw_START_STACK_INCR
#define yy_hlw_START_STACK_INCR 25
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef yy_hlw_DECL
#define yy_hlw_DECL_IS_OURS 1

extern int yy_hlwlex \
               (yy_hlwSTYPE * yy_hlwlval_param ,yy_hlwscan_t yy_hlwscanner);

#define yy_hlw_DECL int yy_hlwlex \
               (yy_hlwSTYPE * yy_hlwlval_param , yy_hlwscan_t yy_hlwscanner)
#endif /* !yy_hlw_DECL */

/* yy_hlw_get_previous_state - get the state just before the EOB char was reached */

#undef yy_hlw_NEW_FILE
#undef yy_hlw_FLUSH_BUFFER
#undef yy_hlw_set_bol
#undef yy_hlw_new_buffer
#undef yy_hlw_set_interactive
#undef yy_hlw_DO_BEFORE_ACTION

#ifdef yy_hlw_DECL_IS_OURS
#undef yy_hlw_DECL_IS_OURS
#undef yy_hlw_DECL
#endif

#line 77 "_jsgf_scanner.l"


#line 355 "jsgf_scanner.h"
#undef yy_hlwIN_HEADER
#endif /* yy_hlwHEADER_H */
