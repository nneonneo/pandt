#!/usr/bin/perl -w

##  OpenEars version 0.913
##  http://www.politepix.com/openears
##
##  InstallOpenEars.pl
##  OpenEars
##
##  With the exception of any material below written by CMU or others, Copyright Halle Winkler 2010,2011, all rights reserved.
##  http://www.politepix.com
##  Contact at http://www.politepix.com/contact
##
##  This file is licensed under the Common Development and Distribution License (CDDL) Version 1.0
##  http://www.opensource.org/licenses/cddl1.txt or see included file license.txt
##  with the single exception to the license that you may distribute executable-only versions
##  of software using OpenEars files without making source code available under the terms of CDDL Version 1.0 
##  paragraph 3.1 if source code to your software isn't otherwise available, and without including a notice in 
##  that case that that source code is available. Exception applies exclusively to compiled binary apps such as can be
##  downloaded from the App Store, and not to frameworks or systems, to which the un-altered CDDL applies
##  unless other terms are agreed to by the copyright holder.

## 1. Generate the iPhone-appropriate config.h file that would normally be generated by ./configure.

$configh = <<"CONFIGHCONTENTS";
/* include/config.h.  Generated from config.h.in by configure.  */
/* include/config.h.in.  Generated from configure.in by autoheader.  */

/* Use ALSA library for sound I/O */
/* #undef AD_BACKEND_ALSA */

/* No interface for sound I/O */
#define AD_BACKEND_NONE 

/* Use OSS for sound I/O */
/* #undef AD_BACKEND_OSS */

/* Use OSS for sound I/O */
/* #undef AD_BACKEND_OSS */

/* Use OSS interface for sound I/O */
/* #undef AD_BACKEND_OSS_BSD */

/* Use SunOS interface for sound I/O */
/* #undef AD_BACKEND_SUNOS */

/* Use WinMM interface for sound I/O */
/* #undef AD_BACKEND_WIN32 */

/* Default radix point for fixed-point */
/* #undef DEFAULT_RADIX */

/* Enable thread safety */
#define ENABLE_THREADS 

/* Use Q15 fixed-point computation */
/* #undef FIXED16 */

/* Use fixed-point computation */
#define FIXED_POINT 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define if you have the iconv() function. */
#define HAVE_ICONV 1

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the `asound' library (-lasound). */
/* #undef HAVE_LIBASOUND */

/* Define to 1 if you have the `blas' library (-lblas). */
/* #undef HAVE_LIBBLAS */

/* Define to 1 if you have the `lapack' library (-llapack). */
/* #undef HAVE_LIBLAPACK */

/* Define to 1 if you have the `m' library (-lm). */
#define HAVE_LIBM 1

/* Define to 1 if you have the `pthread' library (-lpthread). */
#define HAVE_LIBPTHREAD 1

/* Define to 1 if the system has the type `long long'. */
#define HAVE_LONG_LONG 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `perror' function. */
#define HAVE_PERROR 1

/* Define to 1 if you have the `popen' function. */
#define HAVE_POPEN 1

/* Define to 1 if you have the <pthread.h> header file. */
#define HAVE_PTHREAD_H 1

/* Define to 1 if you have the `snprintf' function. */
#define HAVE_SNPRINTF 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Define to the sub-directory in which libtool stores uninstalled libraries.
   */
#define LT_OBJDIR ".libs/"

/* Define to the address where bug reports for this package should be sent. */
#define PACKAGE_BUGREPORT ""

/* Define to the full name of this package. */
#define PACKAGE_NAME "sphinxbase"

/* Define to the full name and version of this package. */
#define PACKAGE_STRING "sphinxbase 0.6.1"

/* Define to the one symbol short name of this package. */
#define PACKAGE_TARNAME "sphinxbase"

/* Define to the version of this package. */
#define PACKAGE_VERSION "0.6.1"

/* Define as the return type of signal handlers (`int' or `void'). */
#define RETSIGTYPE void

/* The size of `long', as computed by sizeof. */
#define SIZEOF_LONG 8

/* The size of `long long', as computed by sizeof. */
#define SIZEOF_LONG_LONG 8

/* Enable debugging output */
/* #undef SPHINX_DEBUG */

/* Define to 1 if you have the ANSI C header files. */
#define STDC_HEADERS 1

/* Enable matrix algebra with LAPACK */
#define WITH_LAPACK 

/* Define to 1 if your processor stores words with the most significant byte
   first (like Motorola and SPARC, unlike Intel and VAX). */
/* #undef WORDS_BIGENDIAN */

CONFIGHCONTENTS
;

open(CONFIGHHANDLE,">sphinxbase-0.6.1/include/config.h")or die "can't open config.h:$!";
print CONFIGHHANDLE $configh;
close(CONFIGHHANDLE);









$voiceconfigh = <<"VOICECONFIGHCONTENTS";
// Uncomment only the voices you want to use in your app so that your binary size is as small as possible:
//#define cmu_us_awb8k // Uncomment this in order to use the (faster) 8k version of the us_awb voice
//#define cmu_us_rms8k // Uncomment this in order to use the (faster) 8k version of the us_rms voice
#define cmu_us_slt8k // Uncomment this in order to use the (faster) 8k version of the us_slt voice
//#define cmu_time_awb // Uncomment this in order to use the 16k awb time voice
//#define cmu_us_awb //  Uncomment this in order to use the 16k us_awb voice
//#define cmu_us_kal //  Uncomment this in order to use the 8k us_kal voice
//#define cmu_us_kal16 // Uncomment this in order to use the 16k us_kal voice
#define cmu_us_rms // Uncomment this in order to use the 16k us_rms voice
//#define cmu_us_slt // Uncomment this in order to use the 16k us_slt voice
VOICECONFIGHCONTENTS
;

open(VOICECONFIGHHANDLE,">flite-1.4-release/include/OpenEarsVoiceConfig.h")or die "can't open OpenEarsVoiceConfig.h:$!";
print VOICECONFIGHHANDLE $voiceconfigh;
close(VOICECONFIGHHANDLE);













## 2. Edit sphinx_config.h for fixed-point and no audio device

my $sphinxconfigfilename = 'sphinxbase-0.6.1/include/sphinx_config.h';
my $find11 = '#define AD_BACKEND_ALSA';
my $replace11 = '/* #undef AD_BACKEND_ALSA */';
my $find21 = '\/\* #undef AD_BACKEND_NONE \*\/';
my $replace21 = '#define AD_BACKEND_NONE';
my $find3 = '\/\* #undef FIXED_POINT \*\/';
my $replace3 = '#define FIXED_POINT 1';
my $find4 = '#define SIZEOF_LONG 4';
my $replace4 = '#define SIZEOF_LONG 8';

local @ARGV = ($sphinxconfigfilename);
local $^I = '.bak';
while( <> ){
	s/$find11/$replace11/ig;
	s/$find21/$replace21/ig;
	s/$find3/$replace3/ig;
	s/$find4/$replace4/ig;
	print;       
};

my $tied_mgau_commonfilename = 'pocketsphinx-0.6.1/src/libpocketsphinx/tied_mgau_common.h';

my $findtied_mgau = '#define LOGMATH_INLINE inline';
$definereplace = <<"DEFINECONTENTS";
#define LOGMATH_INLINE static inline
DEFINECONTENTS
;

local @ARGV = ($tied_mgau_commonfilename);
local $^I = '.bak';
while( <> ){
	s/$findtied_mgau/$definereplace/ig;
	print;       
};

##Now let's fix the Flite files

my $cst_ssmlfilename = 'flite-1.4-release/src/synth/cst_ssml.c';
my $cst_ssmlfind1 = 'feat_print\(stdout,attributes\)';
my $cst_ssmlreplace1 = 'feat_print_flite(stdout,attributes)';

local @ARGV = ($cst_ssmlfilename);
local $^I = '.bak';
while( <> ){
	s/$cst_ssmlfind1/$cst_ssmlreplace1/ig;
	print;       
};

my $cst_featuresfilename = 'flite-1.4-release/src/utils/cst_features.c';
my $cst_featuresfind1 = 'int feat_print\(cst_file fd,const cst_features';
my $cst_featuresreplace1 = 'int feat_print_flite(cst_file fd,const cst_features';

local @ARGV = ($cst_featuresfilename);
local $^I = '.bak';
while( <> ){
	s/$cst_featuresfind1/$cst_featuresreplace1/ig;
	print;       
};




my $cmdlnfilename = 'sphinxbase-0.6.1/src/libsphinxbase/util/cmd_ln.c';
my $cmdlnfind1 = 'strncat\(\*dest, source, source_len';
my $cmdlnreplace1 = 'strlcat(*dest, source, source_len+1';

local @ARGV = ($cmdlnfilename);
local $^I = '.bak';
while( <> ){
	s/$cmdlnfind1/$cmdlnreplace1/ig;
	print;       
};



my $cst_featuresfilenameh = 'flite-1.4-release/include/cst_features.h';

local @ARGV = ($cst_featuresfilenameh);
local $^I = '.bak';
while( <> ){
	s/$cst_featuresfind1/$cst_featuresreplace1/ig;
	print;       
};

my $cst_mlsafilename = 'flite-1.4-release/src/cg/cst_mlsa.c';
my $speedhackdefinefind = '#ifdef UNDER_CE';
my $speedhackdefinereplace = <<"SPEEDHACKDEFINE";
#include "OpenEarsVoiceConfig.h"
#ifdef cmu_us_awb8k
#define SPEED_HACK
#endif
#ifdef cmu_us_rms8k
#define SPEED_HACK
#endif
#ifdef cmu_us_slt8k
#define SPEED_HACK
#endif

#ifdef UNDER_CE
SPEEDHACKDEFINE
;
local @ARGV = ($cst_mlsafilename);
local $^I = '.bak';
while( <> ){
	s/$speedhackdefinefind/$speedhackdefinereplace/ig;
	print;       
};

use File::Slurp;
$cmu_lex_data_raw = read_file('flite-1.4-release/lang/cmulex/cmu_lex_data_raw.c');
$cmu_lex_entries_huff_table = read_file('flite-1.4-release/lang/cmulex/cmu_lex_entries_huff_table.c');
$cmu_lex_num_bytes = read_file('flite-1.4-release/lang/cmulex/cmu_lex_num_bytes.c');

my $cmu_lex_datafilename = 'flite-1.4-release/lang/cmulex/cmu_lex_data.c';
my $cmu_lex_datafind1 = '#include \"cmu_lex_data_raw.c\"';

local @ARGV = ($cmu_lex_datafilename);
local $^I = '.bak';
while( <> ){
	s/$cmu_lex_datafind1/$cmu_lex_data_raw/ig;
	print;       
};

my $cmu_lex_entries1filename = 'flite-1.4-release/lang/cmulex/cmu_lex_entries.c';
my $cmu_lex_entries1find1 = '#include \"cmu_lex_entries_huff_table.c\"';

local @ARGV = ($cmu_lex_entries1filename);
local $^I = '.bak';
while( <> ){
	s/$cmu_lex_entries1find1/$cmu_lex_entries_huff_table/ig;
	print;       
};

my $cmu_lex_entries2filename = 'flite-1.4-release/lang/cmulex/cmu_lex_entries.c';
my $cmu_lex_entries2find1 = '#include \"cmu_lex_num_bytes.c\"';

local @ARGV = ($cmu_lex_entries2filename);
local $^I = '.bak';
while( <> ){
	s/$cmu_lex_entries2find1/$cmu_lex_num_bytes/ig;
	print;       
};



my $ms_gaudenfilename = 'pocketsphinx-0.6.1/src/libpocketsphinx/ms_gauden.c';
my $ms_gaudenfind1 = 'for \(i = 0\; i \< n_feat\; i\+\+\)';
my $ms_gaudenreplace1 = 'for (i = 0; i < n_feat; i++) {';
my $ms_gaudenfind2 = 'printf\(\" \%dx\%d\", n_density, veclen\[i\]\)\;';
my $ms_gaudenreplace2 = <<"GAUDENTOKEN";
// printf(" %dx%d", n_density, veclen[i]);
}
GAUDENTOKEN
;

local @ARGV = ($ms_gaudenfilename);
local $^I = '.bak';
while( <> ){
	s/$ms_gaudenfind1/$ms_gaudenreplace1/ig;
	s/$ms_gaudenfind2/$ms_gaudenreplace2/ig;
	print;       
};




my $featsparamfilename = 'pocketsphinx-0.6.1/model/hmm/en_US/hub4wsj_sc_8k/feat.params';
my $featsparamfind1 = '-cmninit 56,-3,1';
my $featsparamreplace1 = '-cmninit 39';

local @ARGV = ($featsparamfilename);
local $^I = '.bak';
while( <> ){
	s/$featsparamfind1/$featsparamreplace1/ig;
	print;       
};




##$filename = "/tmp/" . $name . ".tmp"; 

my $pathtovoice1 = "wince/voices/src/cmu_us_awb8k/";
my $pathtovoice2 = "wince/voices/src/cmu_us_rms8k/";
my $pathtovoice3 = "wince/voices/src/cmu_us_slt8k/";

my $oldname1forvoice1 = "cmu_us_awb_cg_durmodel.c";
my $oldname2forvoice1 = "cmu_us_awb_cg_durmodel.h";
my $oldname3forvoice1 = "cmu_us_awb_cg_f0_trees.c";
my $oldname4forvoice1 = "cmu_us_awb_cg_f0_trees.h";
my $oldname5forvoice1 = "cmu_us_awb_cg_phonestate.c";
my $oldname6forvoice1 = "cmu_us_awb_cg_single_mcep_trees.c";
my $oldname7forvoice1 = "cmu_us_awb_cg_single_mcep_trees.h";
my $oldname8forvoice1 = "cmu_us_awb_cg_single_params.c";
my $oldname9forvoice1 = "cmu_us_awb_cg.c";
my $oldname10forvoice1 = "cmu_us_awb.c";

my $newname1forvoice1 = "cmu_us_awb8k_cg_durmodel.c";
my $newname2forvoice1 = "cmu_us_awb8k_cg_durmodel.h";
my $newname3forvoice1 = "cmu_us_awb8k_cg_f0_trees.c";
my $newname4forvoice1 = "cmu_us_awb8k_cg_f0_trees.h";
my $newname5forvoice1 = "cmu_us_awb8k_cg_phonestate.c";
my $newname6forvoice1 = "cmu_us_awb8k_cg_single_mcep_trees.c";
my $newname7forvoice1 = "cmu_us_awb8k_cg_single_mcep_trees.h";
my $newname8forvoice1 = "cmu_us_awb8k_cg_single_params.c";
my $newname9forvoice1 = "cmu_us_awb8k_cg.c";
my $newname10forvoice1 = "cmu_us_awb8k.c";

my $oldname1forvoice2 = "cmu_us_rms_cg_durmodel.c";
my $oldname2forvoice2 = "cmu_us_rms_cg_durmodel.h";
my $oldname3forvoice2 = "cmu_us_rms_cg_f0_trees.c";
my $oldname4forvoice2 = "cmu_us_rms_cg_f0_trees.h";
my $oldname5forvoice2 = "cmu_us_rms_cg_phonestate.c";
my $oldname6forvoice2 = "cmu_us_rms_cg_single_mcep_trees.c";
my $oldname7forvoice2 = "cmu_us_rms_cg_single_mcep_trees.h";
my $oldname8forvoice2 = "cmu_us_rms_cg_single_params.c";
my $oldname9forvoice2 = "cmu_us_rms_cg.c";
my $oldname10forvoice2 = "cmu_us_rms.c";

my $newname1forvoice2 = "cmu_us_rms8k_cg_durmodel.c";
my $newname2forvoice2 = "cmu_us_rms8k_cg_durmodel.h";
my $newname3forvoice2 = "cmu_us_rms8k_cg_f0_trees.c";
my $newname4forvoice2 = "cmu_us_rms8k_cg_f0_trees.h";
my $newname5forvoice2 = "cmu_us_rms8k_cg_phonestate.c";
my $newname6forvoice2 = "cmu_us_rms8k_cg_single_mcep_trees.c";
my $newname7forvoice2 = "cmu_us_rms8k_cg_single_mcep_trees.h";
my $newname8forvoice2 = "cmu_us_rms8k_cg_single_params.c";
my $newname9forvoice2 = "cmu_us_rms8k_cg.c";
my $newname10forvoice2 = "cmu_us_rms8k.c";

my $oldname1forvoice3 = "cmu_us_slt_cg_durmodel.c";
my $oldname2forvoice3 = "cmu_us_slt_cg_durmodel.h";
my $oldname3forvoice3 = "cmu_us_slt_cg_f0_trees.c";
my $oldname4forvoice3 = "cmu_us_slt_cg_f0_trees.h";
my $oldname5forvoice3 = "cmu_us_slt_cg_phonestate.c";
my $oldname6forvoice3 = "cmu_us_slt_cg_single_mcep_trees.c";
my $oldname7forvoice3 = "cmu_us_slt_cg_single_mcep_trees.h";
my $oldname8forvoice3 = "cmu_us_slt_cg_single_params.c";
my $oldname9forvoice3 = "cmu_us_slt_cg.c";
my $oldname10forvoice3 = "cmu_us_slt.c";

my $newname1forvoice3 = "cmu_us_slt8k_cg_durmodel.c";
my $newname2forvoice3 = "cmu_us_slt8k_cg_durmodel.h";
my $newname3forvoice3 = "cmu_us_slt8k_cg_f0_trees.c";
my $newname4forvoice3 = "cmu_us_slt8k_cg_f0_trees.h";
my $newname5forvoice3 = "cmu_us_slt8k_cg_phonestate.c";
my $newname6forvoice3 = "cmu_us_slt8k_cg_single_mcep_trees.c";
my $newname7forvoice3 = "cmu_us_slt8k_cg_single_mcep_trees.h";
my $newname8forvoice3 = "cmu_us_slt8k_cg_single_params.c";
my $newname9forvoice3 = "cmu_us_slt8k_cg.c";
my $newname10forvoice3 = "cmu_us_slt8k.c";

rename($pathtovoice1 . $oldname1forvoice1, $pathtovoice1 . $newname1forvoice1) || print "Don't have permission to rename" . $oldname1forvoice1;

rename($pathtovoice1 . $oldname2forvoice1, $pathtovoice1 . $newname2forvoice1) || print "Don't have permission to rename" . $oldname2forvoice1;

rename($pathtovoice1 . $oldname3forvoice1, $pathtovoice1 . $newname3forvoice1) || print "Don't have permission to rename" . $oldname3forvoice1;

rename($pathtovoice1 . $oldname4forvoice1, $pathtovoice1 . $newname4forvoice1) || print "Don't have permission to rename" . $oldname4forvoice1;

rename($pathtovoice1 . $oldname5forvoice1, $pathtovoice1 . $newname5forvoice1) || print "Don't have permission to rename" . $oldname5forvoice1;

rename($pathtovoice1 . $oldname6forvoice1, $pathtovoice1 . $newname6forvoice1) || print "Don't have permission to rename" . $oldname6forvoice1;

rename($pathtovoice1 . $oldname7forvoice1, $pathtovoice1 . $newname7forvoice1) || print "Don't have permission to rename" . $oldname7forvoice1;

rename($pathtovoice1 . $oldname8forvoice1, $pathtovoice1 . $newname8forvoice1) || print "Don't have permission to rename" . $oldname8forvoice1;

rename($pathtovoice1 . $oldname9forvoice1, $pathtovoice1 . $newname9forvoice1) || print "Don't have permission to rename" . $oldname9forvoice1;

rename($pathtovoice1 . $oldname10forvoice1, $pathtovoice1 . $newname10forvoice1) || print "Don't have permission to rename" . $oldname10forvoice1;




rename($pathtovoice2 . $oldname1forvoice2, $pathtovoice2 . $newname1forvoice2) || print "Don't have permission to rename" . $oldname1forvoice2;

rename($pathtovoice2 . $oldname2forvoice2, $pathtovoice2 . $newname2forvoice2) || print "Don't have permission to rename" . $oldname2forvoice2;

rename($pathtovoice2 . $oldname3forvoice2, $pathtovoice2 . $newname3forvoice2) || print "Don't have permission to rename" . $oldname3forvoice2;

rename($pathtovoice2 . $oldname4forvoice2, $pathtovoice2 . $newname4forvoice2) || print "Don't have permission to rename" . $oldname4forvoice2;

rename($pathtovoice2 . $oldname5forvoice2, $pathtovoice2 . $newname5forvoice2) || print "Don't have permission to rename" . $oldname5forvoice2;

rename($pathtovoice2 . $oldname6forvoice2, $pathtovoice2 . $newname6forvoice2) || print "Don't have permission to rename" . $oldname6forvoice2;

rename($pathtovoice2 . $oldname7forvoice2, $pathtovoice2 . $newname7forvoice2) || print "Don't have permission to rename" . $oldname7forvoice2;

rename($pathtovoice2 . $oldname8forvoice2, $pathtovoice2 . $newname8forvoice2) || print "Don't have permission to rename" . $oldname8forvoice2;

rename($pathtovoice2 . $oldname9forvoice2, $pathtovoice2 . $newname9forvoice2) || print "Don't have permission to rename" . $oldname9forvoice2;

rename($pathtovoice2 . $oldname10forvoice2, $pathtovoice2 . $newname10forvoice2) || print "Don't have permission to rename" . $oldname10forvoice2;




rename($pathtovoice3 . $oldname1forvoice3, $pathtovoice3 . $newname1forvoice3) || print "Don't have permission to rename" . $oldname1forvoice3;

rename($pathtovoice3 . $oldname2forvoice3, $pathtovoice3 . $newname2forvoice3) || print "Don't have permission to rename" . $oldname2forvoice3;

rename($pathtovoice3 . $oldname3forvoice3, $pathtovoice3 . $newname3forvoice3) || print "Don't have permission to rename" . $oldname3forvoice3;

rename($pathtovoice3 . $oldname4forvoice3, $pathtovoice3 . $newname4forvoice3) || print "Don't have permission to rename" . $oldname4forvoice3;

rename($pathtovoice3 . $oldname5forvoice3, $pathtovoice3 . $newname5forvoice3) || print "Don't have permission to rename" . $oldname5forvoice3;

rename($pathtovoice3 . $oldname6forvoice3, $pathtovoice3 . $newname6forvoice3) || print "Don't have permission to rename" . $oldname6forvoice3;

rename($pathtovoice3 . $oldname7forvoice3, $pathtovoice3 . $newname7forvoice3) || print "Don't have permission to rename" . $oldname7forvoice3;

rename($pathtovoice3 . $oldname8forvoice3, $pathtovoice3 . $newname8forvoice3) || print "Don't have permission to rename" . $oldname8forvoice3;

rename($pathtovoice3 . $oldname9forvoice3, $pathtovoice3 . $newname9forvoice3) || print "Don't have permission to rename" . $oldname9forvoice3;

rename($pathtovoice3 . $oldname10forvoice3, $pathtovoice3 . $newname10forvoice3) || print "Don't have permission to rename" . $oldname10forvoice3;


local @ARGV = ($pathtovoice1 . $newname1forvoice1);
local $^I = '.bak';
while( <> ){
	s/awb/awb8k/ig;
	print;       
};

local @ARGV = ($pathtovoice1 . $newname2forvoice1);
local $^I = '.bak';
while( <> ){
	s/awb/awb8k/ig;
	print;       
};

local @ARGV = ($pathtovoice1 . $newname3forvoice1);
local $^I = '.bak';
while( <> ){
	s/awb/awb8k/ig;
	print;       
};

local @ARGV = ($pathtovoice1 . $newname4forvoice1);
local $^I = '.bak';
while( <> ){
	s/awb/awb8k/ig;
	print;       
};

local @ARGV = ($pathtovoice1 . $newname5forvoice1);
local $^I = '.bak';
while( <> ){
	s/awb/awb8k/ig;
	print;       
};

local @ARGV = ($pathtovoice1 . $newname6forvoice1);
local $^I = '.bak';
while( <> ){
	s/awb/awb8k/ig;
	print;       
};

local @ARGV = ($pathtovoice1 . $newname7forvoice1);
local $^I = '.bak';
while( <> ){
	s/awb/awb8k/ig;
	print;       
};

local @ARGV = ($pathtovoice1 . $newname8forvoice1);
local $^I = '.bak';
while( <> ){
	s/awb/awb8k/ig;
	print;       
};

local @ARGV = ($pathtovoice1 . $newname9forvoice1);
local $^I = '.bak';
while( <> ){
	s/awb/awb8k/ig;
	print;       
};

local @ARGV = ($pathtovoice1 . $newname10forvoice1);
local $^I = '.bak';
while( <> ){
	s/awb/awb8k/ig;
	print;       
};










local @ARGV = ($pathtovoice2 . $newname1forvoice2);
local $^I = '.bak';
while( <> ){
	s/rms/rms8k/ig;
	print;       
};

local @ARGV = ($pathtovoice2 . $newname2forvoice2);
local $^I = '.bak';
while( <> ){
	s/rms/rms8k/ig;
	print;       
};

local @ARGV = ($pathtovoice2 . $newname3forvoice2);
local $^I = '.bak';
while( <> ){
	s/rms/rms8k/ig;
	print;       
};

local @ARGV = ($pathtovoice2 . $newname4forvoice2);
local $^I = '.bak';
while( <> ){
	s/rms/rms8k/ig;
	print;       
};

local @ARGV = ($pathtovoice2 . $newname5forvoice2);
local $^I = '.bak';
while( <> ){
	s/rms/rms8k/ig;
	print;       
};

local @ARGV = ($pathtovoice2 . $newname6forvoice2);
local $^I = '.bak';
while( <> ){
	s/rms/rms8k/ig;
	print;       
};

local @ARGV = ($pathtovoice2 . $newname7forvoice2);
local $^I = '.bak';
while( <> ){
	s/rms/rms8k/ig;
	print;       
};

local @ARGV = ($pathtovoice2 . $newname8forvoice2);
local $^I = '.bak';
while( <> ){
	s/rms/rms8k/ig;
	print;       
};

local @ARGV = ($pathtovoice2 . $newname9forvoice2);
local $^I = '.bak';
while( <> ){
	s/rms/rms8k/ig;
	print;       
};

local @ARGV = ($pathtovoice2 . $newname10forvoice2);
local $^I = '.bak';
while( <> ){
	s/rms/rms8k/ig;
	print;       
};






local @ARGV = ($pathtovoice3 . $newname1forvoice3);
local $^I = '.bak';
while( <> ){
	s/slt/slt8k/ig;
	print;       
};

local @ARGV = ($pathtovoice3 . $newname2forvoice3);
local $^I = '.bak';
while( <> ){
	s/slt/slt8k/ig;
	print;       
};

local @ARGV = ($pathtovoice3 . $newname3forvoice3);
local $^I = '.bak';
while( <> ){
	s/slt/slt8k/ig;
	print;       
};

local @ARGV = ($pathtovoice3 . $newname4forvoice3);
local $^I = '.bak';
while( <> ){
	s/slt/slt8k/ig;
	print;       
};

local @ARGV = ($pathtovoice3 . $newname5forvoice3);
local $^I = '.bak';
while( <> ){
	s/slt/slt8k/ig;
	print;       
};

local @ARGV = ($pathtovoice3 . $newname6forvoice3);
local $^I = '.bak';
while( <> ){
	s/slt/slt8k/ig;
	print;       
};

local @ARGV = ($pathtovoice3 . $newname7forvoice3);
local $^I = '.bak';
while( <> ){
	s/slt/slt8k/ig;
	print;       
};

local @ARGV = ($pathtovoice3 . $newname8forvoice3);
local $^I = '.bak';
while( <> ){
	s/slt/slt8k/ig;
	print;       
};

local @ARGV = ($pathtovoice3 . $newname9forvoice3);
local $^I = '.bak';
while( <> ){
	s/slt/slt8k/ig;
	print;       
};

local @ARGV = ($pathtovoice3 . $newname10forvoice3);
local $^I = '.bak';
while( <> ){
	s/slt/slt8k/ig;
	print;       
};




$configh3 = <<"CONFIGHCONTENTS3";
/*  ---------------------------------------------------------------  */
/*      The HMM-Based Speech Synthesis System (HTS): version 1.1b    */
/*                        HTS Working Group                          */
/*                                                                   */
/*                   Department of Computer Science                  */
/*                   Nagoya Institute of Technology                  */
/*                                and                                */
/*    Interdisciplinary Graduate School of Science and Engineering   */
/*                   Tokyo Institute of Technology                   */
/*                      Copyright (c) 2001-2003                      */
/*                        All Rights Reserved.                       */
/*                                                                   */
/*  Permission is hereby granted, free of charge, to use and         */
/*  distribute this software and its documentation without           */
/*  restriction, including without limitation the rights to use,     */
/*  copy, modify, merge, publish, distribute, sublicense, and/or     */
/*  sell copies of this work, and to permit persons to whom this     */
/*  work is furnished to do so, subject to the following conditions: */
/*                                                                   */
/*    1. The code must retain the above copyright notice, this list  */
/*       of conditions and the following disclaimer.                 */
/*                                                                   */
/*    2. Any modifications must be clearly marked as such.           */
/*                                                                   */    
/*  NAGOYA INSTITUTE OF TECHNOLOGY, TOKYO INSITITUTE OF TECHNOLOGY,  */
/*  HTS WORKING GROUP, AND THE CONTRIBUTORS TO THIS WORK DISCLAIM    */
/*  ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL       */
/*  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT   */
/*  SHALL NAGOYA INSTITUTE OF TECHNOLOGY, TOKYO INSITITUTE OF        */
/*  TECHNOLOGY, HTS WORKING GROUP, NOR THE CONTRIBUTORS BE LIABLE    */
/*  FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY        */
/*  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  */
/*  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTUOUS   */
/*  ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR          */
/*  PERFORMANCE OF THIS SOFTWARE.                                    */
/*                                                                   */
/*  ---------------------------------------------------------------  */
/*   This is Zen's MLSA filter as ported by Toda to festvox vc       */
/*   and back ported into hts/festival so we can do MLSA filtering   */
/*   If I took more time I could probably make this use the same as  */
/*   as the other code in this directory -- awb_at_cs.cmu.edu 03JAN06   */
/*  ---------------------------------------------------------------  */
/*   and then ported into Flite (November 2007 awb_at_cs.cmu.edu)       */
/*     with some speed uptimizations                                 */

/*********************************************************************/
/*                                                                   */
/*  Mel-cepstral vocoder (pulse/noise excitation & MLSA filter)      */
/*                                    2003/12/26 by Heiga Zen        */
/*                                                                   */
/*  Extracted from HTS and slightly modified                         */
/*   by Tomoki Toda (tomoki_at_ics.nitech.ac.jp)                        */
/*  June 2004                                                        */
/*  Integrate as a Voice Conversion module                           */
/*                                                                   */
/*-------------------------------------------------------------------*/

#include "cst_alloc.h"
#include "cst_string.h"
#include "cst_math.h"
#include "cst_track.h"
#include "cst_wave.h"
#include "cst_audio.h"

#ifdef UNDER_CE
#define double float
#endif

#include "cst_vc.h"
#include "cst_cg.h"
#include "cst_mlsa.h"


static cst_wave *synthesis_body(const cst_track *params, 
                                const cst_track *str, 
                                double fs, double framem,
                                cst_cg_db *cg_db,
                                cst_audio_streaming_info *asi);

cst_wave *mlsa_resynthesis(const cst_track *params, 
                           const cst_track *str, 
                           cst_cg_db *cg_db,
                           cst_audio_streaming_info *asi)
{
    /* Resynthesizes a wave from given track */
    cst_wave *wave = 0;
    int sr = 16000;
    double shift;

    if (params->num_frames > 1)
        shift = 1000.0*(params->times[1]-params->times[0]);
    else
        shift = 5.0;

    wave = synthesis_body(params,str,sr,shift,cg_db,asi);

    return wave;
}

static cst_wave *synthesis_body(const cst_track *params, /* f0 + mcep */
                                const cst_track *str,
                                double fs,	/* sampling frequency (Hz) */
                                double framem,	/* FFT length */
                                cst_cg_db *cg_db,
                                cst_audio_streaming_info *asi)
{
    long t, pos;
    int framel, i;
    double f0;
    VocoderSetup vs;
    cst_wave *wave = 0;
    double *mcep;
    int stream_mark;
    int rc = CST_AUDIO_STREAM_CONT;
    int num_mcep;

    num_mcep = params->num_channels-1;
    framel = (int)(framem * fs / 1000.0);
    init_vocoder(fs, framel, num_mcep, &vs, cg_db);

    if (str != NULL)
        vs.gauss = MFALSE;

    /* synthesize waveforms by MLSA filter */
    wave = new_wave();
    cst_wave_resize(wave,params->num_frames * (framel + 2),1);
	
	if(strcmp (cg_db->name, "cmu_us_awb8k") == 0 || strcmp (cg_db->name, "cmu_us_rms8k") == 0 || strcmp (cg_db->name, "cmu_us_slt8k") == 0) {
		/* This is a SPECTACULAR hack -- basically resample the original */
		/* files to 8KHz but label them as 16KHz and do the full build */
		/* then after synthesis get them to be played at 8KHz -- it works */
		wave->sample_rate = 8000; 
	} else {
		 wave->sample_rate = fs; 
	}

    mcep = cst_alloc(double,num_mcep+1);

    for (t = 0, stream_mark = pos = 0; 
         (rc == CST_AUDIO_STREAM_CONT) && (t < params->num_frames); 
         t++) 
    {
        f0 = (double)params->frames[t][0];
        for (i=1; i<num_mcep+1; i++)
            mcep[i-1] = params->frames[t][i];
        mcep[i-1] = 0;

        vocoder(f0, mcep, str, t, num_mcep, cg_db, &vs, wave, &pos);

        if (asi && (pos-stream_mark > asi->min_buffsize))
        {
            rc=(*asi->asc)(wave,stream_mark,pos-stream_mark,0,asi->userdata);
            stream_mark = pos;
        }
    }
    wave->num_samples = pos;

    if (asi && (rc == CST_AUDIO_STREAM_CONT))
    {   /* drain the last part of the waveform */
        (*asi->asc)(wave,stream_mark,pos-stream_mark,1,asi->userdata);
    }

    /* memory free */
    cst_free(mcep);
    free_vocoder(&vs);

    return wave;
}

static void init_vocoder(double fs, int framel, int m, 
                         VocoderSetup *vs, cst_cg_db *cg_db)
{
    /* initialize global parameter */
    vs->fprd = framel;
    vs->iprd = 1;
    vs->seed = 1;

	if(strcmp (cg_db->name, "cmu_us_awb8k") == 0 || strcmp (cg_db->name, "cmu_us_rms8k") == 0 || strcmp (cg_db->name, "cmu_us_slt8k") == 0) {
		/* This makes it about 25% faster and sounds basically the same */
		vs->pd   = 4;
	} else {
		vs->pd   = 5;
	}

    vs->next =1;
    vs->gauss = MTRUE;

    /* Pade' approximants */
    vs->pade[ 0]=1.0;
    vs->pade[ 1]=1.0; vs->pade[ 2]=0.0;
    vs->pade[ 3]=1.0; vs->pade[ 4]=0.0;      vs->pade[ 5]=0.0;
    vs->pade[ 6]=1.0; vs->pade[ 7]=0.0;      vs->pade[ 8]=0.0;      vs->pade[ 9]=0.0;
    vs->pade[10]=1.0; vs->pade[11]=0.4999273; vs->pade[12]=0.1067005; vs->pade[13]=0.01170221; vs->pade[14]=0.0005656279;
    vs->pade[15]=1.0; vs->pade[16]=0.4999391; vs->pade[17]=0.1107098; vs->pade[18]=0.01369984; vs->pade[19]=0.0009564853;
    vs->pade[20]=0.00003041721;

    vs->rate = fs;
    vs->c = cst_alloc(double,3 * (m + 1) + 3 * (vs->pd + 1) + vs->pd * (m + 2));
   
    vs->p1 = -1;
    vs->sw = 0;
    vs->x  = 0x55555555;
   
    /* for postfiltering */
    vs->mc = NULL;
    vs->o  = 0;
    vs->d  = NULL;
    vs->irleng= 64;
   
    // for MIXED EXCITATION
    vs->ME_order = cg_db->ME_order;
    vs->ME_num = cg_db->ME_num;
    vs->hpulse = cst_alloc(double,vs->ME_order);
    vs->hnoise = cst_alloc(double,vs->ME_order);
    vs->xpulsesig = cst_alloc(double,vs->ME_order);
    vs->xnoisesig = cst_alloc(double,vs->ME_order);
    vs->h = cg_db->me_h;

    return;
}

static double plus_or_minus_one()
{
    /* Randomly return 1 or -1 */
    /* not sure rand() is portable */
    if (rand() > RAND_MAX/2.0)
        return 1.0;
    else
        return -1.0;
}

static void vocoder(double p, double *mc, 
                    const cst_track *str, int t,
                    int m, cst_cg_db *cg_db,
                    VocoderSetup *vs, cst_wave *wav, long *pos)
{
    double inc, x, e1, e2;
    int i, j, k; 
    double xpulse, xnoise;
    double fxpulse, fxnoise;
    float gain=1.0;
    
    if (cg_db->gain != 0.0)
        gain = cg_db->gain;
   
    if (str != NULL)     /* MIXED-EXCITATION */
    {
        /* Copy in str's and build hpulse and hnoise for this frame */
        for (i=0; i<vs->ME_order; i++)
        {
            vs->hpulse[i] = vs->hnoise[i] = 0.0;
            for (j=0; j<vs->ME_num; j++)
            {
                vs->hpulse[i] += str->frames[t][j] * vs->h[j][i];
                vs->hnoise[i] += (1 - str->frames[t][j]) * vs->h[j][i];
            }
        }
    }

    if (p != 0.0)
	p = vs->rate / p;  /* f0 -> pitch */
   
    if (vs->p1 < 0) {
	if (vs->gauss & (vs->seed != 1)) 
	    vs->next = srnd((unsigned)vs->seed);
         
	vs->p1   = p;
	vs->pc   = vs->p1;
	vs->cc   = vs->c + m + 1;
	vs->cinc = vs->cc + m + 1;
	vs->d1   = vs->cinc + m + 1;

	mc2b(mc, vs->c, m, cg_db->mlsa_alpha);
      
	if (cg_db->mlsa_beta > 0.0 && m > 1) {
	    e1 = b2en(vs->c, m, cg_db->mlsa_alpha, vs);
	    vs->c[1] -= cg_db->mlsa_beta * cg_db->mlsa_alpha * mc[2];
	    for (k=2;k<=m;k++)
		vs->c[k] *= (1.0 + cg_db->mlsa_beta);
	    e2 = b2en(vs->c, m, cg_db->mlsa_alpha, vs);
	    vs->c[0] += log(e1/e2)/2;
	}

	return;
    }

    mc2b(mc, vs->cc, m, cg_db->mlsa_alpha); 
    if (cg_db->mlsa_beta>0.0 && m > 1) {
	e1 = b2en(vs->cc, m, cg_db->mlsa_alpha, vs);
	vs->cc[1] -= cg_db->mlsa_beta * cg_db->mlsa_alpha * mc[2];
	for (k = 2; k <= m; k++)
	    vs->cc[k] *= (1.0 + cg_db->mlsa_beta);
	e2 = b2en(vs->cc, m, cg_db->mlsa_alpha, vs);
	vs->cc[0] += log(e1 / e2) / 2.0;
    }

    for (k=0; k<=m; k++)
	vs->cinc[k] = (vs->cc[k] - vs->c[k]) *
	    (double)vs->iprd / (double)vs->fprd;

    if (vs->p1!=0.0 && p!=0.0) {
	inc = (p - vs->p1) * (double)vs->iprd / (double)vs->fprd;
    } else {
	inc = 0.0;
	vs->pc = p;
	vs->p1 = 0.0;
    }

    for (j = vs->fprd, i = (vs->iprd + 1) / 2; j--;) {
	if (vs->p1 == 0.0) {
	    if (vs->gauss)
		x = (double) nrandom(vs);
	    else
		x = plus_or_minus_one();
            if (str != NULL)             /* MIXED EXCITATION */
            {
                xnoise = x;
                xpulse = 0.0;
            }
	} else {
	    if ((vs->pc += 1.0) >= vs->p1) {
		x = sqrt (vs->p1);
		vs->pc = vs->pc - vs->p1;
	    } else 
                x = 0.0;

            if (str != NULL)  /* MIXED EXCITATION */
            {
                xpulse = x;
                xnoise = plus_or_minus_one();
            }
	}

        /* MIXED EXCITATION */
        /* The real work -- apply shaping filters to pulse and noise */
        if (str != NULL)
        {
            fxpulse = fxnoise = 0.0;
            for (k=vs->ME_order-1; k>0; k--)
            {
                fxpulse += vs->hpulse[k] * vs->xpulsesig[k];
                fxnoise += vs->hnoise[k] * vs->xnoisesig[k];

                vs->xpulsesig[k] = vs->xpulsesig[k-1];
                vs->xnoisesig[k] = vs->xnoisesig[k-1];
            }
            fxpulse += vs->hpulse[0] * xpulse;
            fxnoise += vs->hnoise[0] * xnoise;
            vs->xpulsesig[0] = xpulse;
            vs->xnoisesig[0] = xnoise;

            x = fxpulse + fxnoise; /* excitation is pulse plus noise */
        }

		if(strcmp (cg_db->name, "cmu_us_awb8k") == 0 || strcmp (cg_db->name, "cmu_us_rms8k") == 0 || strcmp (cg_db->name, "cmu_us_slt8k") == 0) {
			/* 8KHz voices are too quiet */
			x *= exp(vs->c[0])*2.0;
		} else {
			x *= exp(vs->c[0])*gain;
		}

	x = mlsadf(x, vs->c, m, cg_db->mlsa_alpha, vs->pd, vs->d1, vs);

        wav->samples[*pos] = (short)x;
	*pos += 1;

	if (!--i) {
	    vs->p1 += inc;
	    for (k = 0; k <= m; k++) vs->c[k] += vs->cinc[k];
	    i = vs->iprd;
	}
    }
   
    vs->p1 = p;
    memmove(vs->c,vs->cc,sizeof(double)*(m+1));
   
    return;
}

static double mlsadf(double x, double *b, int m, double a, int pd, double *d, VocoderSetup *vs)
{

   vs->ppade = &(vs->pade[pd*(pd+1)/2]);
    
   x = mlsadf1 (x, b, m, a, pd, d, vs);
   x = mlsadf2 (x, b, m, a, pd, &d[2*(pd+1)], vs);

   return(x);
}

static double mlsadf1(double x, double *b, int m, double a, int pd, double *d, VocoderSetup *vs)
{
   double v, out = 0.0, *pt, aa;
   register int i;

   aa = 1 - a*a;
   pt = &d[pd+1];

   for (i=pd; i>=1; i--) {
      d[i] = aa*pt[i-1] + a*d[i];
      pt[i] = d[i] * b[1];
      v = pt[i] * vs->ppade[i];
      x += (1 & i) ? v : -v;
      out += v;
   }

   pt[0] = x;
   out += x;

   return(out);
}

static double mlsadf2 (double x, double *b, int m, double a, int pd, double *d, VocoderSetup *vs)
{
   double v, out = 0.0, *pt, aa;
   register int i;
    
   aa = 1 - a*a;
   pt = &d[pd * (m+2)];

   for (i=pd; i>=1; i--) {
       pt[i] = mlsafir (pt[i-1], b, m, a, &d[(i-1)*(m+2)]);

       v = pt[i] * vs->ppade[i];

       x  += (1&i) ? v : -v;
       out += v;
   }
    
   pt[0] = x;
   out  += x;

   return(out);
}

static double mlsafir (double x, double *b, int m, double a, double *d)
{  
   double y = 0.0;
   double aa;
   register int i;

   aa = 1 - a*a;

   d[0] = x;
   d[1] = aa*d[0] + a*d[1];
   for (i=2; i<= m; i++) {
      d[i] = d[i] + a*(d[i+1]-d[i-1]);
      y += d[i]*b[i];
   }

   for (i=m+1; i>1; i--) 
      d[i] = d[i-1];

   return(y);
}

static double nrandom (VocoderSetup *vs)
{
   if (vs->sw == 0) {
      vs->sw = 1;
      do {
         vs->r1 = 2.0 * rnd(&vs->next) - 1.0;
         vs->r2 = 2.0 * rnd(&vs->next) - 1.0;
         vs->s  = vs->r1 * vs->r1 + vs->r2 * vs->r2;
      } while (vs->s > 1 || vs->s == 0);

      vs->s = sqrt (-2 * log(vs->s) / vs->s);
      
      return(vs->r1*vs->s);
   }
   else {
      vs->sw = 0;
      
      return (vs->r2*vs->s);
   }
}

static double rnd (unsigned long *next)
{
   double r;

   *next = *next * 1103515245L + 12345;
   r = (*next / 65536L) % 32768L;

   return(r/RANDMAX); 
}

static unsigned long srnd ( unsigned long seed )
{
   return(seed);
}

/* mc2b : transform mel-cepstrum to MLSA digital fillter coefficients */
static void mc2b (double *mc, double *b, int m, double a)
{
   b[m] = mc[m];
    
   for (m--; m>=0; m--)
      b[m] = mc[m] - a * b[m+1];
   
   return;
}


static double b2en (double *b, int m, double a, VocoderSetup *vs)
{
   double en;
   int k;
   
   if (vs->o<m) {
      if (vs->mc != NULL)
          cst_free(vs->mc);
    
      vs->mc = cst_alloc(double,(m + 1) + 2 * vs->irleng);
      vs->cep = vs->mc + m+1;
      vs->ir  = vs->cep + vs->irleng;
   }

   b2mc(b, vs->mc, m, a);
   freqt(vs->mc, m, vs->cep, vs->irleng-1, -a, vs);
   c2ir(vs->cep, vs->irleng, vs->ir, vs->irleng);
   en = 0.0;
   
   for (k=0;k<vs->irleng;k++)
      en += vs->ir[k] * vs->ir[k];

   return(en);
}


/* b2bc : transform MLSA digital filter coefficients to mel-cepstrum */
static void b2mc (double *b, double *mc, int m, double a)
{
  double d, o;
        
  d = mc[m] = b[m];
  for (m--; m>=0; m--) {
    o = b[m] + a * d;
    d = b[m];
    mc[m] = o;
  }
  
  return;
}

/* freqt : frequency transformation */
static void freqt (double *c1, int m1, double *c2, int m2, double a, VocoderSetup *vs)
{
   register int i, j;
   double b;
    
   if (vs->d==NULL) {
      vs->size = m2;
      vs->d    = cst_alloc(double,vs->size + vs->size + 2);
      vs->g    = vs->d+vs->size+1;
   }

   if (m2>vs->size) {
       cst_free(vs->d);
      vs->size = m2;
      vs->d    = cst_alloc(double,vs->size + vs->size + 2);
      vs->g    = vs->d+vs->size+1;
   }
    
   b = 1-a*a;
   for (i=0; i<m2+1; i++)
      vs->g[i] = 0.0;

   for (i=-m1; i<=0; i++) {
      if (0 <= m2)
         vs->g[0] = c1[-i]+a*(vs->d[0]=vs->g[0]);
      if (1 <= m2)
         vs->g[1] = b*vs->d[0]+a*(vs->d[1]=vs->g[1]);
      for (j=2; j<=m2; j++)
         vs->g[j] = vs->d[j-1]+a*((vs->d[j]=vs->g[j])-vs->g[j-1]);
   }

   memmove(c2,vs->g,sizeof(double)*(m2+1));
   
   return;
}

/* c2ir : The minimum phase impulse response is evaluated from the minimum phase cepstrum */
static void c2ir (double *c, int nc, double *h, int leng)
{
   register int n, k, upl;
   double  d;

   h[0] = exp(c[0]);
   for (n=1; n<leng; n++) {
      d = 0;
      upl = (n>=nc) ? nc-1 : n;
      for (k=1; k<=upl; k++)
         d += k*c[k]*h[n-k];
      h[n] = d/n;
   }
   
   return;
}

static void free_vocoder(VocoderSetup *vs)
{

    cst_free(vs->c);
    cst_free(vs->mc);
    cst_free(vs->d);
 
    vs->c = NULL;
    vs->mc = NULL;
    vs->d = NULL;
    vs->ppade = NULL;
    vs->cc = NULL;
    vs->cinc = NULL;
    vs->d1 = NULL;
    vs->g = NULL;
    vs->cep = NULL;
    vs->ir = NULL;

    cst_free(vs->hpulse);
    cst_free(vs->hnoise);
    cst_free(vs->xpulsesig);
    cst_free(vs->xnoisesig);

   
    return;
}



CONFIGHCONTENTS3
;

open(CONFIGHHANDLE3,">flite-1.4-release/src/cg/cst_mlsa.c")or die "can't open cst_mlsa.c:$!";
print CONFIGHHANDLE3 $configh3;
close(CONFIGHHANDLE3);

my $allloadfix1_filename = 'sphinxbase-0.6.1/src/libsphinxbase/lm/jsgf.c';
my $allloadfix2_filename = 'sphinxbase-0.6.1/src/libsphinxbase/lm/jsgf_parser.c';
my $allloadfix3_filename = 'sphinxbase-0.6.1/src/libsphinxbase/lm/jsgf_parser.h';
my $allloadfix4_filename = 'sphinxbase-0.6.1/src/libsphinxbase/lm/jsgf_parser.y';
my $allloadfix5_filename = 'sphinxbase-0.6.1/src/libsphinxbase/lm/jsgf_scanner.c';
my $allloadfix6_filename = 'sphinxbase-0.6.1/src/libsphinxbase/lm/jsgf_scanner.h';

my $allloadfix_find = 'yy';
my $allloadfix_replace = 'yy_hlw';

local @ARGV = ($allloadfix1_filename);
local $^I = '.bak';
while( <> ){
	s/$allloadfix_find/$allloadfix_replace/ig;
	print;       
};

local @ARGV = ($allloadfix2_filename);
local $^I = '.bak';
while( <> ){
	s/$allloadfix_find/$allloadfix_replace/ig;
	print;       
};

local @ARGV = ($allloadfix3_filename);
local $^I = '.bak';
while( <> ){
	s/$allloadfix_find/$allloadfix_replace/ig;
	print;       
};

local @ARGV = ($allloadfix4_filename);
local $^I = '.bak';
while( <> ){
	s/$allloadfix_find/$allloadfix_replace/ig;
	print;       
};

local @ARGV = ($allloadfix5_filename);
local $^I = '.bak';
while( <> ){
	s/$allloadfix_find/$allloadfix_replace/ig;
	print;       
};

local @ARGV = ($allloadfix6_filename);
local $^I = '.bak';
while( <> ){
	s/$allloadfix_find/$allloadfix_replace/ig;
	print;       
};


